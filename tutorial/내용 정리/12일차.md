# 흔한 찐따의 파이썬 12일차 내용 정리
오늘은 파이썬 함수의 종류에 대해 공부하였다.
실질적인 개념은 어렵지 않아서 머리로는 이해했지만,
실제로 사용해서 응용해보라고 한다면 조금 혼란스러울 것 같다.
그래서 예제를 통해 더 많이 공부 해보고 사용을 해봐야 될 것 같다.

## 함수형 패러다임 (Functional Paradigm)
- 파이썬은 객체지향 패러다임만을 제공하는 것이 아니라 다양한 프로그래밍 패러다임을 제공한다.
- 파이썬에서는 수많은 패러다임 중 **함수형 패러다임** 역시 제공한다.
- **함수형 프로그래밍(functional programming)** 은 자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다.
- 객체지향 프로그래밍은 객체를 중심적으로 사고하는 기법이라면, 함수형 프로그래밍은 **거의 모든 것을 순수 함수로 나누어 문제를 해결하는 기법** 이다.
- 작은 문제를 해결하기 위한 함수를 작성하여 가독성을 높이고 유지 보수를 용이하게 해준다.

## 함수의 여러 가지 형태
- 파이썬에는 여러 가지 형태의 함수들이 존재한다.
- 앞서 파이썬에는 함수형 패러다임을 제공한다고 서술했었다.
- 함수형 패러다임에서 사용되는 몇 가지 함수 패턴들이 존재한다.

## 람다 함수 (Lambda Function)
- 람다 함수는 이전에도 배웠던 개념이다.
- 간단한 함수를 한 줄만으로 만들게 해준다.
- 주로 함수를 사용할 수 없는 경우나 간단한 함수를 인자값으로 넘길 때 사용된다.

### 예시
```python
f = lambda x: x + 1
f(10)
```

## 퍼스트 클래스 함수 (First-class Function)
- **퍼스트 클래스** 함수란, 프로그래밍 언어가 함수를 **일급 객체(first-class object 혹은 일등 시민; first-class citizen 라고도 함)** 으로 취급하는 것을 의미한다.
- 함수 자체를 인자(argument)로써 다른 함수에 전달하거나 다른 함수의 결과값으로 반환할 수도 있다.
- 혹은 함수를 변수에 할당하거나 자료 구조안에 저장할 수 있는 함수를 의미한다.
- **즉, 변수에 담을 수 있고, 함수의 인자로 전달하고 함수의 반환값(return value)으로 전달할 수 있는 함수**를 의미한다.

### 일급 객체 (First-class Object)
- **일급 객체**란, 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킨다.
- 보통 함수에 인자로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원할 때 일급 객체라고 한다.

#### 특징
- 변수나 자료 구조 안에 담을 수 있다.
- 파라미터로 전달 할 수 있다.
- 반환값으로 사용할 수 있다.
- 할당에 사용된 이름과 무관하게 고유한 구별이 가능하다.

### 예시
함수를 인자값으로 받는 함수 `f` 를 선언한다.
```python
# 퍼스트 클래스 함수 'f' 선언
def f(x):
    # 여기서 파라미터 'x'는 함수이다.
    # 함수를 호출할 때에는 괄호를 사용한다.
    print("함수 'f' 호출")
    x()
```

그 다음, `함수 'test' 호출` 이라는 메시지를 호출하는 함수 `test` 를 선언한다.
```python
def test():
    print("함수 'test' 호출")
```

함수 `f` 에 인자값으로 함수 `test` 를 넣어주고 호출한다.
```python
f(test)
```

## 중첩 함수 (Nested function)
- **중첩 함수**란, 말 그대로 함수 내에 또 다른 함수를 의미한다.
- 함수 내부에 선언된 함수이므로, **내부 함수(Inner function)** 라고도 한다.

### 예시
아래는 `outer` 라는 함수 안에 `inner` 라는 내부 함수를 선언하는 예시이다.
```python
def outer():
    print("외부 함수 영역")

    def inner():
        print("내부 함수 영역")

    # 내부 함수 'inner' 호출
    inner()

# 함수 'outer' 호출
outer()
```

## nonlocal
- 이전에 배웠던 **`global` 이라는 키워드는 함수 외부에 선언되어있는 변수(즉, 전역 변수)를 사용하기 위한 키워드**이다.
- `nonlocal` 키워드는 `global` 키워드와는 다르게, **중첩 함수의 관계**에서, **내부 함수가 외부 함수의 지역 변수의 값을 다시 할당하려고 할 때 쓰이는 키워드**이다.

### 예시
아래의 코드를 실행하면 `UnboundLocalError` 라는 에러가 발생한다.
```python
def outer():
    a = 10

    def inner():
        a += 10
        print('a:', a)
    inner()

# 함수 'outer'를 호출하면 아래와 같은 에러를 발생시킨다.
# UnboundLocalError: local variable 'a'
outer()
```

- 에러가 발생하는 이유는 **할당하기 전에 지역 변수 `a` 가 이미 참조되었기 때문**이다.
- 즉, 변수 `a` 가 외부 함수의 지역 변수로써의 `a` 인지, 내부 함수의 지역 변수로써의 `a` 인지를 구별하지 못하고 있는 것이다.
  - 이전에 공부했었던 **이름 공간**이라는 개념을 생각해보면 된다.
- 이러한 문제를 해결하기 위해서 변수 `a` 를 아래와 같이 `nonlocal` 로 선언하면 된다.

```python
def outer():
    print("외부 함수 영역")
    a = 10

    # 내부 함수 'inner' 호출
    def inner():
        print("내부 함수 영역")

        # nonlocal 키워드를 사용하여 함수 'outer' 영역에 선언된 변수 'a'를 사용하겠다는 의미이다.
        nonlocal a
        a += 10
        print('a:', a)

    # 내부 함수 'inner' 호출
    inner()

# 함수 'outer' 호출
outer()
```

## 클로저 함수 (Closer Function)
- **클로저** 함수란, 어떤 함수를 함수 자신이 가지고 있는 환경과 함께 저장하는 함수이다.
- 또한 함수가 가진 **프리 변수(free variable)** 를 클로저 함수가 만들어지는 당시의 값과 참조된 값들을 맵핑(mapping)해주는 역할을 한다.
  - 파이썬에서 **프리 변수**란, 코드 블럭안에서 사용은 되었지만, 그 코드 블럭안에서 정의되지 않은 변수를 의미한다.
- 클로저 함수는 일반 함수와는 다르게, 자신의 영역 밖에서 호출된 함수의 변수값과 참조된 값들을 복사하고 저장한 뒤, 이 값들에 접근할 수 있게 도와준다.
- 즉, 간단히 말해서 **클로저 함수란, 자신이 가지고 있는 환경에 맞춰진 형태로 반환해주는 함수**이다.

### 예시
아래는 클로저 함수 `outer` 와 내부 함수인 `inner` 를 실행시킨 결과값을 반환하는 예시이다.
```python
# 클로저 함수 'outer' 정의
def outer():
    # 함수 'outer' 영역의 변수 'msg'
    msg = 'Hi'

    # 내부 함수 'inner' 정의
    def inner():
        # 내부 함수 'inner' 역시 함수 'outer' 영역에 있다.
        # 재선언을 하는 것이 아니기 때문에 함수 'outer' 영역의 변수 'msg'임을 알 수 있다.
        # 따라서 지역 변수 'msg'를 참조할 수 있다. (프리 변수)
        print(msg)

    # 함수 'inner'를 호출하면서 실행 결과를 반환시킨다.
    # 반환되는 값이 없으므로, 결과값은 'None'이 반환된다.
    return inner()

# 클로저 함수 'outer' 호출
outer()
```

### 응용
다음과 같이 함수를 반환시키는 함수를 만들어서 응용할 수도 있다.
```python
# 클로저 함수 'f' 정의
def f(x):
    # 내부 함수 'g' 정의
    def g(y):
        # 클로저 함수 'f'의 파라미터 'x'의 값과 내부 함수 'g'의 파라미터 'y'의 값을 더해준다.
        return x + y
    # 내부 함수 'g'를 반환한다.
    return g

# 함수 'f'는 함수를 반환시키는 함수이므로, 아래와 같이 호출할 수 있다.
# 아래와 같은 방식을 마치 사슬처럼 엮여있는 모양이라고 해서 체이닝(chaining) 기법이라고 한다.
f(1)(2)
```

위와 같은 방식을 마치 사슬처럼 엮여있는 모양이라고 해서 **체이닝(chaining) 기법**이라고 한다.

## 데코레이터 (Decorator)
- **데코레이터**란, 함수와 메서드를 장식(decorate)하는 문법적인 요소이다.
- 사용할 때에는 `@` 기호를 붙여서 사용한다.

이해하기 쉽게 정의하자면 다음과 같다.
- 이전에 `lambda` 함수같은 경우, 함수의 간단한 표현 방식이라고 서술하였다.
- 데코레이터는 함수를 인자로 받는 함수, 즉 **퍼스트 클래스 함수를 문법적인 요소로 간편하게 표현한 것**이다.

### 데코레이터 함수 선언하기
1. 함수를 인자로 받는 함수를 선언한다.
2. 함수 안에 또다른 함수(내부 함수)를 정의한다.
3. 새롭게 정의한 내부 함수를 반환한다.
4. 이렇게 정의한 함수를 `@` 기호를 붙여 `@함수명` 으로 새롭게 정의한 함수 윗줄에 추가한다.

### 예시
먼저, 아래의 예시처럼 함수를 인자로 받는 클로저 함수 `f` 를 정의한다.
```python
def f(x):
    print("함수 'f' 호출")

    # 내부 함수 'g'를 정의한다.
    def g(y):
        print("함수 'g' 호출")
        # 함수를 인자로 받았기 때문에 'function' 타입이 출력된다.
        print(x)
        print(type(x))

        # 인자값으로 받은 함수 'x'에 함수 'g'의 인자값 'y'를 넘긴다.
        return x(y)

    # 내부 함수 'g'를 반환시킨다.
    return g
```

그 다음 새롭게 정의할 함수 윗줄에 `@` 기호를 붙여 다음과 같이 정의한다.
```python
@f
def f2(x):
    print("함수 'f2' 호출")
    return x + 1
```

그 다음 아래의 코드를 실행시켜본다.
```python
y = f2(10)
print(y)
```

#### 결과와 설명
위의 코드를 실행하면 결과는 다음과 같이 출력된다.
```
함수 'f' 호출
함수 'g' 호출
<function f2 at 0x.....>
<class 'function'>
함수 'f2' 호출
11
```

과정은 다음과 같다.
1. 함수 `f` 에 인자값으로 `x` 가 넘어가며, `x` 는 함수이다.
2. 내부 함수 `g` 에 인자값으로 받은 함수 `x` 가 넘어간다.
3. 내부 함수 `g` 에서 인자값으로 넘긴 함수 `x` 에 내부 함수 `g` 의 인자값 `y` 를 넘긴다.
4. 내부 함수 `g` 는 최종적으로 인자값으로 넘긴 함수 `x` 를 실행시킨 결과값을 반환시킨다.
5. 결과적으로, 함수 `f` 는 위의 과정을 거쳐 만들어진 내부 함수 `g` 를 반환한다.
6. 함수 `f` 가 호출된다.
7. 함수 `f` 의 인자값 `x` 로 `f2` 가 넘어간다.
8. 내부 함수 `g` 에서 인자값으로 받은 함수 `f2` 에 인자값 `y` 를 넘기면서 함수 `f2` 를 호출시킨 후, 그 결과값을 반환되도록 만들어진다.
9. 이렇게 만들어진 내부 함수 `g` 를 반환한다.
10. 내부 함수 `g` 가 호출된다.
11. 최종적으로, 내부 함수 `g` 는 함수 `f2` 를 호출한다.

> 과정을 전부 풀어서 보면 매우 복잡해 보이지만, 알고 보면 사실 굉장히 단순하다.
